<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-site-verification" content="LFrbNrn-QMY0TYg3V0MrZ7Kn23s_XTx2z6gmq3urJFA" />
    <title>RPG Adventure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #2c1810, #4a2c18);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            user-select: none;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        canvas {
            background: linear-gradient(45deg, #1a4a1a, #2d5a2d);
            flex: 1;
            display: block;
        }

        .ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }

        .mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 120px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            pointer-events: none;
        }

        .dpad {
            position: relative;
            width: 120px;
            height: 120px;
            pointer-events: all;
        }

        .dpad-button {
            position: absolute;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.1s;
            user-select: none;
        }

        .dpad-button:active {
            background: rgba(255, 255, 255, 0.6);
            transform: scale(0.95);
        }

        .dpad-up { top: 0; left: 40px; }
        .dpad-down { bottom: 0; left: 40px; }
        .dpad-left { top: 40px; left: 0; }
        .dpad-right { top: 40px; right: 0; }

        .action-buttons {
            display: flex;
            gap: 15px;
            pointer-events: all;
        }

        .action-button {
            width: 60px;
            height: 60px;
            background: rgba(255, 100, 100, 0.3);
            border: 2px solid rgba(255, 100, 100, 0.7);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .action-button:active {
            background: rgba(255, 100, 100, 0.7);
            transform: scale(0.95);
        }

        .inventory {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #8B4513;
            border-radius: 10px;
            padding: 20px;
            color: white;
            display: none;
            z-index: 20;
            max-width: 400px;
            width: 90%;
        }

        .inventory h3 {
            margin-bottom: 15px;
            color: #FFD700;
            text-align: center;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .inventory-slot {
            width: 50px;
            height: 50px;
            border: 2px solid #8B4513;
            background: rgba(139, 69, 19, 0.2);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .close-btn {
            background: #8B4513;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            display: block;
            margin: 0 auto;
        }

        .message {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            display: none;
            z-index: 15;
            max-width: 300px;
            text-align: center;
        }

        @media (min-width: 768px) {
            .mobile-controls {
                display: none;
            }
        }

        @media (max-width: 767px) {
            .ui {
                font-size: 12px;
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="ui">
            <div>Level: <span id="level">1</span></div>
            <div>HP: <span id="hp">100</span>/<span id="maxHp">100</span></div>
            <div>XP: <span id="xp">0</span>/<span id="xpNext">100</span></div>
            <div>Gold: <span id="gold">0</span></div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div class="mobile-controls">
            <div class="dpad">
                <div class="dpad-button dpad-up" data-key="ArrowUp">↑</div>
                <div class="dpad-button dpad-down" data-key="ArrowDown">↓</div>
                <div class="dpad-button dpad-left" data-key="ArrowLeft">←</div>
                <div class="dpad-button dpad-right" data-key="ArrowRight">→</div>
            </div>
            <div class="action-buttons">
                <div class="action-button" data-key="KeyX">ATK</div>
                <div class="action-button" data-key="KeyI">INV</div>
            </div>
        </div>

        <div class="inventory" id="inventory">
            <h3>Inventory</h3>
            <div class="inventory-grid" id="inventoryGrid"></div>
            <button class="close-btn" onclick="toggleInventory()">Close</button>
        </div>

        <div class="message" id="message"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        // Made by PKAutuly02
        // Responsive canvas sizing
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game state
        const game = {
            level: 1,
            hp: 100,
            maxHp: 100,
            xp: 0,
            xpNext: 100,
            gold: 0,
            keys: {},
            camera: { x: 0, y: 0 },
            tileSize: 32,
            mapWidth: 50,
            mapHeight: 50
        };

        // Player object
        const player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            width: 24,
            height: 24,
            speed: 3,
            color: '#4169E1',
            lastAttack: 0,
            attackCooldown: 500
        };

        // Game objects
        let enemies = [];
        let items = [];
        let particles = [];
        let trees = [];
        let rocks = [];

        // Sprite creation system
        const sprites = {};

        function createSprite(name, width, height, drawFunction) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            drawFunction(ctx, width, height);
            sprites[name] = canvas;
        }

        function initSprites() {
            // Player sprite
            createSprite('player', 24, 24, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#4169E1';
                ctx.fillRect(8, 8, 8, 12);
                // Head
                ctx.fillStyle = '#FFDBAC';
                ctx.fillRect(8, 4, 8, 8);
                // Hair
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(8, 4, 8, 4);
                // Arms
                ctx.fillStyle = '#FFDBAC';
                ctx.fillRect(4, 10, 4, 6);
                ctx.fillRect(16, 10, 4, 6);
                // Legs
                ctx.fillStyle = '#654321';
                ctx.fillRect(8, 16, 3, 8);
                ctx.fillRect(13, 16, 3, 8);
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(10, 6, 1, 1);
                ctx.fillRect(13, 6, 1, 1);
            });

            // Goblin sprite
            createSprite('goblin', 20, 20, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#228B22';
                ctx.fillRect(6, 8, 8, 8);
                // Head
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(6, 4, 8, 8);
                // Ears
                ctx.fillStyle = '#228B22';
                ctx.fillRect(4, 6, 2, 2);
                ctx.fillRect(14, 6, 2, 2);
                // Arms
                ctx.fillRect(2, 10, 4, 4);
                ctx.fillRect(14, 10, 4, 4);
                // Legs
                ctx.fillRect(6, 14, 3, 6);
                ctx.fillRect(11, 14, 3, 6);
                // Eyes (red)
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(8, 6, 1, 1);
                ctx.fillRect(11, 6, 1, 1);
                // Weapon
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(18, 4, 2, 8);
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(18, 4, 2, 3);
            });
            // Made by PKAutuly02
            // Orc sprite
            createSprite('orc', 20, 20, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(5, 8, 10, 8);
                // Head
                ctx.fillStyle = '#654321';
                ctx.fillRect(5, 3, 10, 8);
                // Tusks
                ctx.fillStyle = '#FFF';
                ctx.fillRect(7, 9, 1, 2);
                ctx.fillRect(12, 9, 1, 2);
                // Arms
                ctx.fillStyle = '#654321';
                ctx.fillRect(1, 10, 4, 5);
                ctx.fillRect(15, 10, 4, 5);
                // Legs
                ctx.fillRect(5, 14, 4, 6);
                ctx.fillRect(11, 14, 4, 6);
                // Eyes (red)
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(7, 5, 2, 1);
                ctx.fillRect(11, 5, 2, 1);
                // Armor
                ctx.fillStyle = '#696969';
                ctx.fillRect(6, 9, 8, 2);
            });

            // Wolf sprite
            createSprite('wolf', 20, 20, (ctx, w, h) => {
                // Body
                ctx.fillStyle = '#696969';
                ctx.fillRect(4, 10, 12, 6);
                // Head
                ctx.fillRect(2, 8, 6, 6);
                // Ears
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(2, 6, 2, 3);
                ctx.fillRect(5, 6, 2, 3);
                // Tail
                ctx.fillStyle = '#696969';
                ctx.fillRect(14, 8, 4, 3);
                // Legs
                ctx.fillRect(5, 14, 2, 4);
                ctx.fillRect(8, 14, 2, 4);
                ctx.fillRect(11, 14, 2, 4);
                ctx.fillRect(14, 14, 2, 4);
                // Eyes
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(3, 9, 1, 1);
                ctx.fillRect(5, 9, 1, 1);
                // Nose
                ctx.fillStyle = '#000';
                ctx.fillRect(1, 10, 1, 1);
            });

            // Tree sprite
            createSprite('tree', 24, 32, (ctx, w, h) => {
                // Trunk
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(8, 20, 8, 12);
                // Tree crown
                ctx.fillStyle = '#228B22';
                ctx.fillRect(4, 4, 16, 20);
                // Tree highlights
                ctx.fillStyle = '#32CD32';
                ctx.fillRect(6, 8, 4, 4);
                ctx.fillRect(14, 12, 4, 4);
                ctx.fillRect(8, 16, 4, 4);
            });

            // Rock sprite
            createSprite('rock', 20, 16, (ctx, w, h) => {
                // Main rock
                ctx.fillStyle = '#696969';
                ctx.fillRect(2, 4, 16, 12);
                // Rock highlights
                ctx.fillStyle = '#A9A9A9';
                ctx.fillRect(4, 6, 4, 3);
                ctx.fillRect(12, 8, 4, 3);
                // Rock shadows
                ctx.fillStyle = '#2F4F4F';
                ctx.fillRect(2, 12, 16, 4);
            });

            // Health potion sprite
            createSprite('healthPotion', 16, 16, (ctx, w, h) => {
                // Bottle
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(5, 2, 6, 12);
                // Potion liquid
                ctx.fillStyle = '#FF1493';
                ctx.fillRect(6, 4, 4, 9);
                // Cork
                ctx.fillStyle = '#654321';
                ctx.fillRect(6, 1, 4, 3);
                // Highlight
                ctx.fillStyle = '#FFB6C1';
                ctx.fillRect(7, 5, 1, 6);
            });

            // Gold coin sprite
            createSprite('goldCoin', 16, 16, (ctx, w, h) => {
                // Coin base
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(3, 3, 10, 10);
                // Inner circle
                ctx.fillStyle = '#FFA500';
                ctx.fillRect(5, 5, 6, 6);
                // Shine
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(6, 6, 2, 2);
                ctx.fillRect(9, 8, 1, 1);
            });

            // Sword sprite
            createSprite('sword', 16, 16, (ctx, w, h) => {
                // Handle
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(7, 12, 2, 4);
                // Guard
                ctx.fillStyle = '#C0C0C0';
                ctx.fillRect(5, 10, 6, 2);
                // Blade
                ctx.fillStyle = '#E6E6FA';
                ctx.fillRect(7, 2, 2, 10);
                // Blade edge
                ctx.fillStyle = '#FFF';
                ctx.fillRect(7, 2, 1, 8);
            });

            // Apple sprite
            createSprite('apple', 16, 16, (ctx, w, h) => {
                // Apple body
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(4, 6, 8, 8);
                // Apple highlight
                ctx.fillStyle = '#FF6347';
                ctx.fillRect(5, 7, 3, 3);
                // Apple stem
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(7, 4, 2, 3);
                // Leaf
                ctx.fillStyle = '#228B22';
                ctx.fillRect(8, 4, 3, 2);
            });
        }

        // Inventory system
        const inventory = {
            items: [],
            maxSlots: 16,
            add(item) {
                if (this.items.length < this.maxSlots) {
                    const existing = this.items.find(i => i.name === item.name);
                    if (existing) {
                        existing.quantity += item.quantity || 1;
                    } else {
                        this.items.push({ ...item, quantity: item.quantity || 1 });
                    }
                    return true;
                }
                return false;
            }
        };
        // Made By PKAutuly02
        // Generate world
        function generateWorld() {
            // Generate trees
            for (let i = 0; i < 200; i++) {
                trees.push({
                    x: Math.random() * (game.mapWidth * game.tileSize),
                    y: Math.random() * (game.mapHeight * game.tileSize),
                    width: 24,
                    height: 32
                });
            }

            // Generate rocks
            for (let i = 0; i < 100; i++) {
                rocks.push({
                    x: Math.random() * (game.mapWidth * game.tileSize),
                    y: Math.random() * (game.mapHeight * game.tileSize),
                    width: 20,
                    height: 16
                });
            }

            // Generate enemies
            for (let i = 0; i < 50; i++) {
                spawnEnemy();
            }

            // Generate items
            for (let i = 0; i < 30; i++) {
                spawnItem();
            }
        }

        function spawnEnemy() {
            const types = [
                { name: 'Goblin', hp: 30, damage: 10, xp: 25, gold: 5, sprite: 'goblin', speed: 1.5 },
                { name: 'Orc', hp: 60, damage: 20, xp: 50, gold: 10, sprite: 'orc', speed: 1 },
                { name: 'Wolf', hp: 40, damage: 15, xp: 30, gold: 3, sprite: 'wolf', speed: 2 }
            ];

            const type = types[Math.floor(Math.random() * types.length)];
            enemies.push({
                x: Math.random() * (game.mapWidth * game.tileSize),
                y: Math.random() * (game.mapHeight * game.tileSize),
                width: 20,
                height: 20,
                maxHp: type.hp,
                hp: type.hp,
                damage: type.damage,
                xp: type.xp,
                gold: type.gold,
                speed: type.speed,
                sprite: type.sprite,
                name: type.name,
                lastMove: 0,
                direction: Math.random() * Math.PI * 2
            });
        }

        function spawnItem() {
            const itemTypes = [
                { name: 'Health Potion', sprite: 'healthPotion', value: 50, type: 'consumable' },
                { name: 'Gold Coin', sprite: 'goldCoin', value: 10, type: 'currency' },
                { name: 'Sword', sprite: 'sword', value: 100, type: 'weapon' },
                { name: 'Apple', sprite: 'apple', value: 20, type: 'consumable' }
            ];

            const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
            items.push({
                x: Math.random() * (game.mapWidth * game.tileSize),
                y: Math.random() * (game.mapHeight * game.tileSize),
                width: 16,
                height: 16,
                ...type
            });
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            game.keys[e.code] = true;
            
            if (e.code === 'KeyX') attack();
            if (e.code === 'KeyI') toggleInventory();
        });

        document.addEventListener('keyup', (e) => {
            game.keys[e.code] = false;
        });

        // Mobile controls
        document.querySelectorAll('.dpad-button, .action-button').forEach(button => {
            button.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const key = button.getAttribute('data-key');
                game.keys[key] = true;
                
                if (key === 'KeyX') attack();
                if (key === 'KeyI') toggleInventory();
            });

            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                const key = button.getAttribute('data-key');
                game.keys[key] = false;
            });
        });

        // Game functions
        function updatePlayer() {
            let newX = player.x;
            let newY = player.y;

            if (game.keys['ArrowLeft']) newX -= player.speed;
            if (game.keys['ArrowRight']) newX += player.speed;
            if (game.keys['ArrowUp']) newY -= player.speed;
            if (game.keys['ArrowDown']) newY += player.speed;

            // Collision detection with world bounds
            if (newX >= 0 && newX <= game.mapWidth * game.tileSize - player.width) {
                player.x = newX;
            }
            if (newY >= 0 && newY <= game.mapHeight * game.tileSize - player.height) {
                player.y = newY;
            }

            // Update camera to follow player
            game.camera.x = player.x - canvas.width / 2;
            game.camera.y = player.y - canvas.height / 2;

            // Keep camera within bounds
            game.camera.x = Math.max(0, Math.min(game.camera.x, game.mapWidth * game.tileSize - canvas.width));
            game.camera.y = Math.max(0, Math.min(game.camera.y, game.mapHeight * game.tileSize - canvas.height));
        }

        function updateEnemies() {
            enemies.forEach((enemy, index) => {
                const now = Date.now();
                
                // Simple AI - move towards player if close
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 100) {
                    // Chase player
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                } else if (now - enemy.lastMove > 2000) {
                    // Random movement
                    enemy.direction += (Math.random() - 0.5) * 0.5;
                    enemy.lastMove = now;
                }

                // Random movement
                if (distance >= 100) {
                    enemy.x += Math.cos(enemy.direction) * enemy.speed * 0.5;
                    enemy.y += Math.sin(enemy.direction) * enemy.speed * 0.5;
                }

                // Keep enemies within bounds
                enemy.x = Math.max(0, Math.min(enemy.x, game.mapWidth * game.tileSize - enemy.width));
                enemy.y = Math.max(0, Math.min(enemy.y, game.mapHeight * game.tileSize - enemy.height));

                // Attack player if close
                if (distance < 30 && now - (enemy.lastAttack || 0) > 1000) {
                    takeDamage(enemy.damage);
                    enemy.lastAttack = now;
                    createParticles(player.x + player.width/2, player.y + player.height/2, '#FF0000');
                }
            });
        }

        function updateItems() {
            items.forEach((item, index) => {
                const dx = player.x - item.x;
                const dy = player.y - item.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 25) {
                    collectItem(item);
                    items.splice(index, 1);
                }
            });
        }

        function attack() {
            const now = Date.now();
            if (now - player.lastAttack < player.attackCooldown) return;

            player.lastAttack = now;
            createParticles(player.x + player.width/2, player.y + player.height/2, '#FFD700');

            enemies.forEach((enemy, index) => {
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 50) {
                    enemy.hp -= 25;
                    createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#FF0000');

                    if (enemy.hp <= 0) {
                        gainXP(enemy.xp);
                        game.gold += enemy.gold;
                        createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#FFD700', 10);
                        enemies.splice(index, 1);
                        
                        // Respawn enemy elsewhere
                        setTimeout(() => spawnEnemy(), 5000);
                    }
                }
            });
        }

        function collectItem(item) {
            if (item.type === 'currency') {
                game.gold += item.value;
                showMessage(`Found ${item.value} gold!`);
            } else if (item.type === 'consumable' && item.name === 'Health Potion') {
                game.hp = Math.min(game.maxHp, game.hp + item.value);
                showMessage(`Restored ${item.value} HP!`);
            } else if (item.type === 'consumable' && item.name === 'Apple') {
                game.hp = Math.min(game.maxHp, game.hp + item.value);
                showMessage(`Ate apple! +${item.value} HP!`);
            } else {
                if (inventory.add(item)) {
                    showMessage(`Found ${item.name}!`);
                } else {
                    showMessage('Inventory full!');
                }
            }

            createParticles(item.x + item.width/2, item.y + item.height/2, '#00FF00');
        }

        function takeDamage(damage) {
            game.hp -= damage;
            if (game.hp <= 0) {
                game.hp = 0;
                showMessage('Game Over! Refresh to restart.');
            }
        }

        function gainXP(xp) {
            game.xp += xp;
            if (game.xp >= game.xpNext) {
                levelUp();
            }
        }

        function levelUp() {
            game.level++;
            game.xp = 0;
            game.xpNext = game.level * 100;
            game.maxHp += 20;
            game.hp = game.maxHp;
            showMessage(`Level Up! Now level ${game.level}!`);
            createParticles(player.x + player.width/2, player.y + player.height/2, '#FFD700', 15);
        }

        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    size: Math.random() * 4 + 2,
                    color: color,
                    life: 1.0,
                    decay: 0.02
                });
            }
        }

        function updateParticles() {
            particles.forEach((particle, index) => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                particle.life -= particle.decay;

                if (particle.life <= 0) {
                    particles.splice(index, 1);
                }
            });
        }

        function showMessage(text) {
            const messageEl = document.getElementById('message');
            messageEl.textContent = text;
            messageEl.style.display = 'block';
            setTimeout(() => {
                messageEl.style.display = 'none';
            }, 3000);
        }

        function toggleInventory() {
            const inventoryEl = document.getElementById('inventory');
            const isVisible = inventoryEl.style.display === 'block';
            inventoryEl.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                updateInventoryDisplay();
            }
        }

        function updateInventoryDisplay() {
            const gridEl = document.getElementById('inventoryGrid');
            gridEl.innerHTML = '';

            for (let i = 0; i < inventory.maxSlots; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                
                if (i < inventory.items.length) {
                    const item = inventory.items[i];
                    slot.title = `${item.name} (${item.quantity})`;
                    
                    // Create mini canvas for sprite
                    const miniCanvas = document.createElement('canvas');
                    miniCanvas.width = 32;
                    miniCanvas.height = 32;
                    const miniCtx = miniCanvas.getContext('2d');
                    
                    if (sprites[item.sprite]) {
                        // Scale sprite to fit slot
                        miniCtx.imageSmoothingEnabled = false;
                        miniCtx.drawImage(sprites[item.sprite], 0, 0, sprites[item.sprite].width, sprites[item.sprite].height, 
                                        8, 8, 16, 16);
                    }
                    
                    slot.appendChild(miniCanvas);
                    
                    // Add quantity text if > 1
                    if (item.quantity > 1) {
                        const quantityEl = document.createElement('div');
                        quantityEl.style.position = 'absolute';
                        quantityEl.style.bottom = '2px';
                        quantityEl.style.right = '2px';
                        quantityEl.style.color = 'white';
                        quantityEl.style.fontSize = '10px';
                        quantityEl.style.fontWeight = 'bold';
                        quantityEl.style.textShadow = '1px 1px 1px black';
                        quantityEl.textContent = item.quantity;
                        slot.style.position = 'relative';
                        slot.appendChild(quantityEl);
                    }
                }
                
                gridEl.appendChild(slot);
            }
        }

        function updateUI() {
            document.getElementById('level').textContent = game.level;
            document.getElementById('hp').textContent = game.hp;
            document.getElementById('maxHp').textContent = game.maxHp;
            document.getElementById('xp').textContent = game.xp;
            document.getElementById('xpNext').textContent = game.xpNext;
            document.getElementById('gold').textContent = game.gold;
        }

        // Rendering functions
        function render() {
            ctx.fillStyle = '#2d5a2d';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grass pattern
            ctx.fillStyle = '#1a4a1a';
            for (let x = 0; x < canvas.width; x += 64) {
                for (let y = 0; y < canvas.height; y += 64) {
                    if ((Math.floor(x/64) + Math.floor(y/64)) % 2) {
                        ctx.fillRect(x, y, 64, 64);
                    }
                }
            }

            // Draw trees
            trees.forEach(tree => {
                const screenX = tree.x - game.camera.x;
                const screenY = tree.y - game.camera.y;
                
                if (screenX > -tree.width && screenX < canvas.width && screenY > -tree.height && screenY < canvas.height) {
                    ctx.drawImage(sprites.tree, screenX, screenY);
                }
            });
            // Made By PKAutuly02
            // Draw rocks
            rocks.forEach(rock => {
                const screenX = rock.x - game.camera.x;
                const screenY = rock.y - game.camera.y;
                
                if (screenX > -rock.width && screenX < canvas.width && screenY > -rock.height && screenY < canvas.height) {
                    ctx.drawImage(sprites.rock, screenX, screenY);
                }
            });

            // Draw items
            items.forEach(item => {
                const screenX = item.x - game.camera.x;
                const screenY = item.y - game.camera.y;
                
                if (screenX > -item.width && screenX < canvas.width && screenY > -item.height && screenY < canvas.height) {
                    // Add slight bobbing animation
                    const bobOffset = Math.sin(Date.now() * 0.005 + item.x * 0.01) * 2;
                    ctx.drawImage(sprites[item.sprite], screenX, screenY + bobOffset);
                }
            });

            // Draw enemies
            enemies.forEach(enemy => {
                const screenX = enemy.x - game.camera.x;
                const screenY = enemy.y - game.camera.y;
                
                if (screenX > -enemy.width && screenX < canvas.width && screenY > -enemy.height && screenY < canvas.height) {
                    ctx.drawImage(sprites[enemy.sprite], screenX, screenY);
                    
                    // Health bar
                    const hpPercent = enemy.hp / enemy.maxHp;
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(screenX, screenY - 8, enemy.width, 4);
                    ctx.fillStyle = '#00FF00';
                    ctx.fillRect(screenX, screenY - 8, enemy.width * hpPercent, 4);
                }
            });

            // Draw player
            const screenX = player.x - game.camera.x;
            const screenY = player.y - game.camera.y;
            ctx.drawImage(sprites.player, screenX, screenY);

            // Draw particles
            particles.forEach(particle => {
                const screenX = particle.x - game.camera.x;
                const screenY = particle.y - game.camera.y;
                
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.fillRect(screenX, screenY, particle.size, particle.size);
                ctx.globalAlpha = 1;
            });
        }

        // Game loop
        function gameLoop() {
            updatePlayer();
            updateEnemies();
            updateItems();
            updateParticles();
            render();
            updateUI();
            requestAnimationFrame(gameLoop);
        }

        // Initialize game
        initSprites();
        generateWorld();
        gameLoop();
        // Made By PKAutuly02
    </script>
    <!-- Credit Section -->
<div style="position:fixed; top:10px; right:10px; 
  background:rgba(0,0,0,0.5); 
  padding:8px; 
  border-radius:8px; 
  color:white; 
  font-size:14px; 
  text-align:right; 
  aspect-ratio:3/1; 
  width:300px; 
  display:flex; 
  flex-direction:column; 
  justify-content:center;">
  This game is created by <b>Sv. Aadarsh Aaryan</b><br>
  <a href="https://www.instagram.com/aadarshaaryan.official/" target="_blank" style="color:#FFD700; text-decoration:none;">Instagram</a>
     <nav>
        <a href = "about.html"color=#39FF14;>More</a>
     </nav>
</div>
</body>
</html>
